import { DynamicModule, Module, Provider } from "@nestjs/common";
import { GraphQLClient } from "graphql-request";
import {
  HasuraInstanceOptions,
  HasuraModuleAsyncOptions,
  HasuraModuleAsyncOptionsClass,
  HasuraModuleOptions,
  HasuraOptionsFactory,
  isMultiInstanceOptions,
  mergeGraphqlClientOptions,
  NamedHasuraInstanceOptions,
} from "./hasura.module-options";
import {
  HASURA_GRAPHQL_CLIENT_INJECT,
  HASURA_GRAPHQL_CLIENT_OPTIONS_INJECT,
  HASURA_INSTANCE_OPTIONS_INJECT,
  HASURA_MODULE_OPTIONS_INJECT,
  HASURA_SDK_INJECT,
  HASURA_SDK_OPTIONS_INJECT,
  NAMED_HASURA_CODEGEN_INJECT,
  NAMED_HASURA_GRAPHQL_CLIENT_INJECT,
  NAMED_HASURA_GRAPHQL_CLIENT_OPTIONS_INJECT,
  NAMED_HASURA_INSTANCE_OPTIONS_INJECT,
  NAMED_HASURA_SDK_INJECT,
  NAMED_HASURA_SDK_OPTIONS_INJECT,
} from "./hasura.constants";
import { HasuraService } from "./hasura.service";
import { SYNC_REGISTER_CODEGEN_ENBALED } from "./hasura.error-messages";
import {  HasuraCodegenService } from "./hasura-codegen.service";
import { GetSdk } from "./hasura-sdk.types";

@Module({})
export class HasuraModule {
  /**
   * Synchronously register the module. Not compatible with managed code generation
   * @param options 
   * @param getSdk 
   */
  static register(options: HasuraModuleOptions, getSdk: GetSdk): DynamicModule {
    // Test if provided instances are correctly configured for manual codegen.
    // Synchronous module registration does not support managed codegen
    HasuraModule.testValidSynchronousRegisterConfig(options)

    return {
      module: HasuraModule,
      providers: [
        {
          provide: HASURA_MODULE_OPTIONS_INJECT,
          useValue: options,
        },

      ],
    };
  }

  static registerAsync(options: HasuraModuleAsyncOptions): DynamicModule {
    const providers: Provider[] = [];

    let optionsProvider: Provider;

    if ("useFactory" in options) {
      optionsProvider = {
        provide: HASURA_MODULE_OPTIONS_INJECT,
        useFactory: options.useFactory,
        inject: options.inject ?? [],
      };
    } else {
      const inject =
        "useExisting" in options ? options.useExisting : options.useClass;

      optionsProvider = {
        provide: HASURA_MODULE_OPTIONS_INJECT,
        useFactory: async (optionsFactory: HasuraOptionsFactory) =>
          await optionsFactory.createHausraOptions(),
        inject: [inject],
      };
    }

    if ("useExisting" in options || "useFactory" in options) {
      providers.push(optionsProvider);
    } else {
      providers.push(optionsProvider);
      providers.push({
        provide: (options as HasuraModuleAsyncOptionsClass).useClass,
        useClass: options.useClass,
      });
    }

    return {
      module: HasuraModule,
      imports: options.imports ?? [],
      providers: [],
    };
  }

  /**
   * Creates providers to inject configuration for each provided Hasura instance
   * @param options 
   */
  private static createInstanceOptionsProviders(options: HasuraModuleOptions): Provider[] {
    if (isMultiInstanceOptions(options)) {
      return options.instances.map((i: NamedHasuraInstanceOptions): Provider => {
        return {
          provide: NAMED_HASURA_INSTANCE_OPTIONS_INJECT(i.name),
          useValue: i
        }
      })
    } else {
      return [{
        provide: HASURA_INSTANCE_OPTIONS_INJECT,
        useValue: options
      }]
    }
  }

  /**
   * Create GraphQL Request Client providers for each instance
   * @param options
   */
  private static createGraphQLClientProviders(
    options: HasuraModuleOptions
  ): Provider[] {
    if (isMultiInstanceOptions(options)) {
      return options.instances
        .map((i): Provider[] => [
          {
            provide: NAMED_HASURA_GRAPHQL_CLIENT_OPTIONS_INJECT(i.name),
            useValue: mergeGraphqlClientOptions(i),
          },
          {
            provide: NAMED_HASURA_GRAPHQL_CLIENT_INJECT(i.name),
            useValue: new GraphQLClient(
              HasuraService.hasuraGraphqlUrl(i),
              mergeGraphqlClientOptions(i)
            ),
          },
        ])
        .reduce((acc, curr) => acc.concat(curr));
    } else {
      return [
        {
          provide: HASURA_GRAPHQL_CLIENT_OPTIONS_INJECT,
          useValue: mergeGraphqlClientOptions(options),
        },
        {
          provide: HASURA_GRAPHQL_CLIENT_INJECT,
          useValue: new GraphQLClient(
            HasuraService.hasuraGraphqlUrl(options),
            mergeGraphqlClientOptions(options)
          ),
        },
      ];
    }
  }

  /**
   * Create the providers for the Sdk (generated by GraphQL Code Generator)
   * @param options
   */
  private static createSdkProviders(options: HasuraModuleOptions, getSdk?: GetSdk): Provider[] {
    if ("instances" in options) {
      return options.instances
        .map((i): Provider[] => [
          {
            provide: NAMED_HASURA_SDK_OPTIONS_INJECT(i.name),
            useValue: i.sdkOptions,
          },
          {
            provide: NAMED_HASURA_CODEGEN_INJECT(i.name),
            useValue: new HasuraCodegenService(i)
          },         
          {
            provide: NAMED_HASURA_SDK_INJECT(i.name),
            async useFactory(client: GraphQLClient, codegen: HasuraCodegenService) {
              return HasuraModule.getHasuraInstanceSdk
            },
            inject: [NAMED_HASURA_GRAPHQL_CLIENT_INJECT(i.name), NAMED_HASURA_CODEGEN_INJECT(i.name)]
          },
        ])
        .reduce((acc, curr) => acc.concat(curr));
    } else {
      return [
        {
          provide: HASURA_SDK_OPTIONS_INJECT,
          useValue: options.sdkOptions,
        },
        {
          provide: HASURA_SDK_INJECT,
          useValue:
        },
      ];
    }
  }

  private static getHasuraInstanceSdk(instance: HasuraInstanceOptions ,client: GraphQLClient, codegen: HasuraCodegenService, getSdk?: GetSdk): Promise<unknown> | unknown {
    if (!!getSdk) {
      return getSdk(client)
    }          

    await codegen.graphqlCodegen()
    const generated = await import(codegen.generatedFile())

    if(!('getSdk' in generated)) {
      throw new Error('Generated file missing getSdk')
    }

    return generated.getSdk(client, instance.sdkOptions?.codegen?.requestMiddleware ?? ((x: unknown) => x)) 
  }

  private static testValidSynchronousRegisterConfig(options: HasuraModuleOptions): void {
    let instanceTests: Promise<boolean>[];
    if (isMultiInstanceOptions(options)) {
      instanceTests = options.instances.map(i => HasuraService.hasuraInstanceOptionsValidForRootRegistration(i))
    } else {
      instanceTests = [HasuraService.hasuraInstanceOptionsValidForRootRegistration(options)]
    }

    if (!instanceTests.every(t => !!t)) {
      throw new Error(SYNC_REGISTER_CODEGEN_ENBALED)
    }
  }
}
