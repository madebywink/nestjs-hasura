import { DynamicModule, Module, Provider } from "@nestjs/common";
import { GraphQLClient } from "graphql-request";
import {
  HasuraModuleAsyncOptions,
  HasuraModuleOptions,
  HasuraOptionsFactory,
  mergeGraphqlClientOptions,
} from "./hasura.module-options";
import { HasuraService } from "./hasura.service";
import { SYNC_REGISTER_CODEGEN_ENBALED } from "./hasura.error-messages";
import { HasuraCodegenService } from "./hasura-codegen.service";
import { GetSdk } from "./hasura-sdk.types";
import { HasuraDescriptorToken, HasuraInjectionToken } from "./hasura.tokens";
import { HasuraWebhookHandlerHeaderGuard } from "./guards/hasura-webhook-handler-header.guard";

@Module({})
export class HasuraModule {
  /**
   * Synchronously register the module. Not compatible with managed code generation
   * @param options
   * @param getSdk
   */
  static register(options: HasuraModuleOptions, getSdk: GetSdk): DynamicModule {
    // Test if provided instances are correctly configured for manual codegen.
    // Synchronous module registration does not support managed codegen
    if (!HasuraService.hasuraInstanceOptionsValidForRootRegistration(options)) {
      throw new Error(SYNC_REGISTER_CODEGEN_ENBALED);
    }

    return {
      module: HasuraModule,
      providers: [
        {
          provide: HasuraInjectionToken.ModuleOptions,
          useValue: options,
        },
        {
          provide: HasuraInjectionToken.GraphQLClientOptions,
          useValue: mergeGraphqlClientOptions(options),
        },
        {
          provide: HasuraInjectionToken.GraphQLClient,
          useValue: new GraphQLClient(
            HasuraService.hasuraGraphqlUrl(options),
            mergeGraphqlClientOptions(options)
          ),
        },
        {
          provide: HasuraInjectionToken.SdkOptions,
          useValue: options.sdkOptions ?? HasuraDescriptorToken.Empty,
        },
        {
          provide: HasuraInjectionToken.Sdk,
          useFactory(graphQLClient: GraphQLClient) {
            return getSdk(graphQLClient);
          },
          inject: [HasuraInjectionToken.GraphQLClient],
        },
        ...HasuraModule.staticProviders,
      ],
    };
  }

  static registerAsync(
    options: HasuraModuleAsyncOptions,
    getSdk?: GetSdk
  ): DynamicModule {
    let providers: Provider[] = [];
    let moduleOptionsProvider: Provider;

    if ("useClass" in options) {
      moduleOptionsProvider = {
        provide: HasuraInjectionToken.ModuleOptions,
        async useFactory(optionsFactory: HasuraOptionsFactory) {
          return optionsFactory.createHausraOptions();
        },
        inject: [options.useClass],
      };
    }

    if ("useExisting" in options) {
      moduleOptionsProvider = {
        provide: HasuraInjectionToken.ModuleOptions,
        async useFactory(optionsFactory: HasuraOptionsFactory) {
          return optionsFactory.createHausraOptions();
        },
        inject: [options.useExisting],
      };
    }

    providers.push(moduleOptionsProvider);

    if ("useClass" in options) {
      providers.push({
        provide: options.useClass,
        useClass: options.useClass,
      });
    }

    return {
      module: HasuraModule,
      imports: options.imports,
      providers: [
        ...providers,
        {
          provide: HasuraInjectionToken.GraphQLClientOptions,
          useFactory(options: HasuraModuleOptions) {
            return mergeGraphqlClientOptions(options);
          },
          inject: [HasuraInjectionToken.ModuleOptions],
        },
        {
          provide: HasuraInjectionToken.GraphQLClient,
          useFactory(options: HasuraModuleOptions) {
            return new GraphQLClient(
              HasuraService.hasuraGraphqlUrl(options),
              mergeGraphqlClientOptions(options)
            );
          },
          inject: [HasuraInjectionToken.ModuleOptions],
        },
        {
          provide: HasuraInjectionToken.SdkOptions,
          useFactory(options: HasuraModuleOptions) {
            return options.sdkOptions ?? HasuraDescriptorToken.Empty;
          },
          inject: [HasuraInjectionToken.ModuleOptions],
        },
        {
          provide: HasuraInjectionToken.Sdk,
          useFactory(graphQLClient: GraphQLClient) {
            if (typeof getSdk === "function") {
              return getSdk(graphQLClient);
            }

            return HasuraDescriptorToken.Empty;
          },
          inject: [HasuraInjectionToken.GraphQLClient],
        },
        ...HasuraModule.staticProviders,
      ],
    };
  }

  /**
   * Gets the generated GraphQL Sdk either from a manually generated getSdk function (as in the case of sync registration)
   * or by dynamically importing the Sdk generated by HasuraCodgenService
   *
   * @param moduleOptions HasuraModuleOptions instance
   * @param client GraphQL Client instance
   * @param codegen HasuraCodegenService instance
   * @param getSdk optional getSdk function in the case of sync registration
   */
  static async getHasuraSdk(
    moduleOptions: HasuraModuleOptions,
    client: GraphQLClient,
    codegen: HasuraCodegenService,
    getSdk?: GetSdk
  ) {
    if (!!getSdk) {
      return getSdk(client);
    }

    try {
      await codegen.graphqlCodegen();
    } catch (e) {
      console.log("Failed to generate Hasura Sdk during module registration");
      console.error(e);
      throw e;
    }
    const generated = await import(codegen.generatedFile());

    if (!("getSdk" in generated)) {
      throw new Error("Generated file missing getSdk");
    }

    return generated.getSdk(
      client,
      moduleOptions.sdkOptions?.codegen?.requestMiddleware ??
        ((x: unknown) => x)
    );
  }

  private static staticProviders: Provider[] = [
    HasuraCodegenService,
    HasuraWebhookHandlerHeaderGuard,
  ];
}
